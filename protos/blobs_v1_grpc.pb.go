// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.12.4
// source: protos/blobs_v1.proto

package protos

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// BlobsClient is the client API for Blobs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BlobsClient interface {
	GetBlobsByFilter(ctx context.Context, in *BlobInfoPageRequest, opts ...grpc.CallOption) (*BlobInfoPageReply, error)
	GetBlobsByIds(ctx context.Context, in *BlobIdsRequest, opts ...grpc.CallOption) (*BlobInfoObjectsReply, error)
	GetBlobById(ctx context.Context, in *BlobIdRequest, opts ...grpc.CallOption) (*BlobInfoObjectReply, error)
	GetBlobUriById(ctx context.Context, in *BlobIdRequest, opts ...grpc.CallOption) (*BlobUriReply, error)
	BeginBlobWrite(ctx context.Context, in *BlobInfoObjectRequest, opts ...grpc.CallOption) (*BlobTokenReply, error)
	WriteBlobChunk(ctx context.Context, in *BlobTokenWithChunkRequest, opts ...grpc.CallOption) (*BlobTokenReply, error)
	EndBlobWrite(ctx context.Context, in *BlobTokenWithChunkRequest, opts ...grpc.CallOption) (*BlobInfoObjectReply, error)
	AbortBlobWrite(ctx context.Context, in *BlobTokenRequest, opts ...grpc.CallOption) (*BlobEmptyReply, error)
	BeginBlobRead(ctx context.Context, in *BlobIdRequest, opts ...grpc.CallOption) (*BlobInfoObjectReply, error)
	ReadBlobChunk(ctx context.Context, in *BlobReadRequest, opts ...grpc.CallOption) (*BlobChunkReply, error)
	EndBlobRead(ctx context.Context, in *BlobIdRequest, opts ...grpc.CallOption) (*BlobEmptyReply, error)
	UpdateBlobInfo(ctx context.Context, in *BlobInfoObjectRequest, opts ...grpc.CallOption) (*BlobInfoObjectReply, error)
	MarkBlobsCompleted(ctx context.Context, in *BlobIdsRequest, opts ...grpc.CallOption) (*BlobEmptyReply, error)
	DeleteBlobById(ctx context.Context, in *BlobIdRequest, opts ...grpc.CallOption) (*BlobEmptyReply, error)
	DeleteBlobsByIds(ctx context.Context, in *BlobIdsRequest, opts ...grpc.CallOption) (*BlobEmptyReply, error)
}

type blobsClient struct {
	cc grpc.ClientConnInterface
}

func NewBlobsClient(cc grpc.ClientConnInterface) BlobsClient {
	return &blobsClient{cc}
}

func (c *blobsClient) GetBlobsByFilter(ctx context.Context, in *BlobInfoPageRequest, opts ...grpc.CallOption) (*BlobInfoPageReply, error) {
	out := new(BlobInfoPageReply)
	err := c.cc.Invoke(ctx, "/blobs_v1.Blobs/get_blobs_by_filter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobsClient) GetBlobsByIds(ctx context.Context, in *BlobIdsRequest, opts ...grpc.CallOption) (*BlobInfoObjectsReply, error) {
	out := new(BlobInfoObjectsReply)
	err := c.cc.Invoke(ctx, "/blobs_v1.Blobs/get_blobs_by_ids", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobsClient) GetBlobById(ctx context.Context, in *BlobIdRequest, opts ...grpc.CallOption) (*BlobInfoObjectReply, error) {
	out := new(BlobInfoObjectReply)
	err := c.cc.Invoke(ctx, "/blobs_v1.Blobs/get_blob_by_id", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobsClient) GetBlobUriById(ctx context.Context, in *BlobIdRequest, opts ...grpc.CallOption) (*BlobUriReply, error) {
	out := new(BlobUriReply)
	err := c.cc.Invoke(ctx, "/blobs_v1.Blobs/get_blob_uri_by_id", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobsClient) BeginBlobWrite(ctx context.Context, in *BlobInfoObjectRequest, opts ...grpc.CallOption) (*BlobTokenReply, error) {
	out := new(BlobTokenReply)
	err := c.cc.Invoke(ctx, "/blobs_v1.Blobs/begin_blob_write", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobsClient) WriteBlobChunk(ctx context.Context, in *BlobTokenWithChunkRequest, opts ...grpc.CallOption) (*BlobTokenReply, error) {
	out := new(BlobTokenReply)
	err := c.cc.Invoke(ctx, "/blobs_v1.Blobs/write_blob_chunk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobsClient) EndBlobWrite(ctx context.Context, in *BlobTokenWithChunkRequest, opts ...grpc.CallOption) (*BlobInfoObjectReply, error) {
	out := new(BlobInfoObjectReply)
	err := c.cc.Invoke(ctx, "/blobs_v1.Blobs/end_blob_write", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobsClient) AbortBlobWrite(ctx context.Context, in *BlobTokenRequest, opts ...grpc.CallOption) (*BlobEmptyReply, error) {
	out := new(BlobEmptyReply)
	err := c.cc.Invoke(ctx, "/blobs_v1.Blobs/abort_blob_write", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobsClient) BeginBlobRead(ctx context.Context, in *BlobIdRequest, opts ...grpc.CallOption) (*BlobInfoObjectReply, error) {
	out := new(BlobInfoObjectReply)
	err := c.cc.Invoke(ctx, "/blobs_v1.Blobs/begin_blob_read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobsClient) ReadBlobChunk(ctx context.Context, in *BlobReadRequest, opts ...grpc.CallOption) (*BlobChunkReply, error) {
	out := new(BlobChunkReply)
	err := c.cc.Invoke(ctx, "/blobs_v1.Blobs/read_blob_chunk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobsClient) EndBlobRead(ctx context.Context, in *BlobIdRequest, opts ...grpc.CallOption) (*BlobEmptyReply, error) {
	out := new(BlobEmptyReply)
	err := c.cc.Invoke(ctx, "/blobs_v1.Blobs/end_blob_read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobsClient) UpdateBlobInfo(ctx context.Context, in *BlobInfoObjectRequest, opts ...grpc.CallOption) (*BlobInfoObjectReply, error) {
	out := new(BlobInfoObjectReply)
	err := c.cc.Invoke(ctx, "/blobs_v1.Blobs/update_blob_info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobsClient) MarkBlobsCompleted(ctx context.Context, in *BlobIdsRequest, opts ...grpc.CallOption) (*BlobEmptyReply, error) {
	out := new(BlobEmptyReply)
	err := c.cc.Invoke(ctx, "/blobs_v1.Blobs/mark_blobs_completed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobsClient) DeleteBlobById(ctx context.Context, in *BlobIdRequest, opts ...grpc.CallOption) (*BlobEmptyReply, error) {
	out := new(BlobEmptyReply)
	err := c.cc.Invoke(ctx, "/blobs_v1.Blobs/delete_blob_by_id", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobsClient) DeleteBlobsByIds(ctx context.Context, in *BlobIdsRequest, opts ...grpc.CallOption) (*BlobEmptyReply, error) {
	out := new(BlobEmptyReply)
	err := c.cc.Invoke(ctx, "/blobs_v1.Blobs/delete_blobs_by_ids", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BlobsServer is the server API for Blobs service.
// All implementations must embed UnimplementedBlobsServer
// for forward compatibility
type BlobsServer interface {
	GetBlobsByFilter(context.Context, *BlobInfoPageRequest) (*BlobInfoPageReply, error)
	GetBlobsByIds(context.Context, *BlobIdsRequest) (*BlobInfoObjectsReply, error)
	GetBlobById(context.Context, *BlobIdRequest) (*BlobInfoObjectReply, error)
	GetBlobUriById(context.Context, *BlobIdRequest) (*BlobUriReply, error)
	BeginBlobWrite(context.Context, *BlobInfoObjectRequest) (*BlobTokenReply, error)
	WriteBlobChunk(context.Context, *BlobTokenWithChunkRequest) (*BlobTokenReply, error)
	EndBlobWrite(context.Context, *BlobTokenWithChunkRequest) (*BlobInfoObjectReply, error)
	AbortBlobWrite(context.Context, *BlobTokenRequest) (*BlobEmptyReply, error)
	BeginBlobRead(context.Context, *BlobIdRequest) (*BlobInfoObjectReply, error)
	ReadBlobChunk(context.Context, *BlobReadRequest) (*BlobChunkReply, error)
	EndBlobRead(context.Context, *BlobIdRequest) (*BlobEmptyReply, error)
	UpdateBlobInfo(context.Context, *BlobInfoObjectRequest) (*BlobInfoObjectReply, error)
	MarkBlobsCompleted(context.Context, *BlobIdsRequest) (*BlobEmptyReply, error)
	DeleteBlobById(context.Context, *BlobIdRequest) (*BlobEmptyReply, error)
	DeleteBlobsByIds(context.Context, *BlobIdsRequest) (*BlobEmptyReply, error)
	mustEmbedUnimplementedBlobsServer()
}

// UnimplementedBlobsServer must be embedded to have forward compatible implementations.
type UnimplementedBlobsServer struct {
}

func (UnimplementedBlobsServer) GetBlobsByFilter(context.Context, *BlobInfoPageRequest) (*BlobInfoPageReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlobsByFilter not implemented")
}
func (UnimplementedBlobsServer) GetBlobsByIds(context.Context, *BlobIdsRequest) (*BlobInfoObjectsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlobsByIds not implemented")
}
func (UnimplementedBlobsServer) GetBlobById(context.Context, *BlobIdRequest) (*BlobInfoObjectReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlobById not implemented")
}
func (UnimplementedBlobsServer) GetBlobUriById(context.Context, *BlobIdRequest) (*BlobUriReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlobUriById not implemented")
}
func (UnimplementedBlobsServer) BeginBlobWrite(context.Context, *BlobInfoObjectRequest) (*BlobTokenReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BeginBlobWrite not implemented")
}
func (UnimplementedBlobsServer) WriteBlobChunk(context.Context, *BlobTokenWithChunkRequest) (*BlobTokenReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteBlobChunk not implemented")
}
func (UnimplementedBlobsServer) EndBlobWrite(context.Context, *BlobTokenWithChunkRequest) (*BlobInfoObjectReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EndBlobWrite not implemented")
}
func (UnimplementedBlobsServer) AbortBlobWrite(context.Context, *BlobTokenRequest) (*BlobEmptyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbortBlobWrite not implemented")
}
func (UnimplementedBlobsServer) BeginBlobRead(context.Context, *BlobIdRequest) (*BlobInfoObjectReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BeginBlobRead not implemented")
}
func (UnimplementedBlobsServer) ReadBlobChunk(context.Context, *BlobReadRequest) (*BlobChunkReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadBlobChunk not implemented")
}
func (UnimplementedBlobsServer) EndBlobRead(context.Context, *BlobIdRequest) (*BlobEmptyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EndBlobRead not implemented")
}
func (UnimplementedBlobsServer) UpdateBlobInfo(context.Context, *BlobInfoObjectRequest) (*BlobInfoObjectReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBlobInfo not implemented")
}
func (UnimplementedBlobsServer) MarkBlobsCompleted(context.Context, *BlobIdsRequest) (*BlobEmptyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkBlobsCompleted not implemented")
}
func (UnimplementedBlobsServer) DeleteBlobById(context.Context, *BlobIdRequest) (*BlobEmptyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBlobById not implemented")
}
func (UnimplementedBlobsServer) DeleteBlobsByIds(context.Context, *BlobIdsRequest) (*BlobEmptyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBlobsByIds not implemented")
}
func (UnimplementedBlobsServer) mustEmbedUnimplementedBlobsServer() {}

// UnsafeBlobsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BlobsServer will
// result in compilation errors.
type UnsafeBlobsServer interface {
	mustEmbedUnimplementedBlobsServer()
}

func RegisterBlobsServer(s grpc.ServiceRegistrar, srv BlobsServer) {
	s.RegisterService(&Blobs_ServiceDesc, srv)
}

func _Blobs_GetBlobsByFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobInfoPageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobsServer).GetBlobsByFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blobs_v1.Blobs/get_blobs_by_filter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobsServer).GetBlobsByFilter(ctx, req.(*BlobInfoPageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blobs_GetBlobsByIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobsServer).GetBlobsByIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blobs_v1.Blobs/get_blobs_by_ids",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobsServer).GetBlobsByIds(ctx, req.(*BlobIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blobs_GetBlobById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobsServer).GetBlobById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blobs_v1.Blobs/get_blob_by_id",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobsServer).GetBlobById(ctx, req.(*BlobIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blobs_GetBlobUriById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobsServer).GetBlobUriById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blobs_v1.Blobs/get_blob_uri_by_id",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobsServer).GetBlobUriById(ctx, req.(*BlobIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blobs_BeginBlobWrite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobInfoObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobsServer).BeginBlobWrite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blobs_v1.Blobs/begin_blob_write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobsServer).BeginBlobWrite(ctx, req.(*BlobInfoObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blobs_WriteBlobChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobTokenWithChunkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobsServer).WriteBlobChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blobs_v1.Blobs/write_blob_chunk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobsServer).WriteBlobChunk(ctx, req.(*BlobTokenWithChunkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blobs_EndBlobWrite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobTokenWithChunkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobsServer).EndBlobWrite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blobs_v1.Blobs/end_blob_write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobsServer).EndBlobWrite(ctx, req.(*BlobTokenWithChunkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blobs_AbortBlobWrite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobsServer).AbortBlobWrite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blobs_v1.Blobs/abort_blob_write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobsServer).AbortBlobWrite(ctx, req.(*BlobTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blobs_BeginBlobRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobsServer).BeginBlobRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blobs_v1.Blobs/begin_blob_read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobsServer).BeginBlobRead(ctx, req.(*BlobIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blobs_ReadBlobChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobsServer).ReadBlobChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blobs_v1.Blobs/read_blob_chunk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobsServer).ReadBlobChunk(ctx, req.(*BlobReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blobs_EndBlobRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobsServer).EndBlobRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blobs_v1.Blobs/end_blob_read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobsServer).EndBlobRead(ctx, req.(*BlobIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blobs_UpdateBlobInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobInfoObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobsServer).UpdateBlobInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blobs_v1.Blobs/update_blob_info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobsServer).UpdateBlobInfo(ctx, req.(*BlobInfoObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blobs_MarkBlobsCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobsServer).MarkBlobsCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blobs_v1.Blobs/mark_blobs_completed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobsServer).MarkBlobsCompleted(ctx, req.(*BlobIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blobs_DeleteBlobById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobsServer).DeleteBlobById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blobs_v1.Blobs/delete_blob_by_id",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobsServer).DeleteBlobById(ctx, req.(*BlobIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blobs_DeleteBlobsByIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobsServer).DeleteBlobsByIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blobs_v1.Blobs/delete_blobs_by_ids",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobsServer).DeleteBlobsByIds(ctx, req.(*BlobIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Blobs_ServiceDesc is the grpc.ServiceDesc for Blobs service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Blobs_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "blobs_v1.Blobs",
	HandlerType: (*BlobsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "get_blobs_by_filter",
			Handler:    _Blobs_GetBlobsByFilter_Handler,
		},
		{
			MethodName: "get_blobs_by_ids",
			Handler:    _Blobs_GetBlobsByIds_Handler,
		},
		{
			MethodName: "get_blob_by_id",
			Handler:    _Blobs_GetBlobById_Handler,
		},
		{
			MethodName: "get_blob_uri_by_id",
			Handler:    _Blobs_GetBlobUriById_Handler,
		},
		{
			MethodName: "begin_blob_write",
			Handler:    _Blobs_BeginBlobWrite_Handler,
		},
		{
			MethodName: "write_blob_chunk",
			Handler:    _Blobs_WriteBlobChunk_Handler,
		},
		{
			MethodName: "end_blob_write",
			Handler:    _Blobs_EndBlobWrite_Handler,
		},
		{
			MethodName: "abort_blob_write",
			Handler:    _Blobs_AbortBlobWrite_Handler,
		},
		{
			MethodName: "begin_blob_read",
			Handler:    _Blobs_BeginBlobRead_Handler,
		},
		{
			MethodName: "read_blob_chunk",
			Handler:    _Blobs_ReadBlobChunk_Handler,
		},
		{
			MethodName: "end_blob_read",
			Handler:    _Blobs_EndBlobRead_Handler,
		},
		{
			MethodName: "update_blob_info",
			Handler:    _Blobs_UpdateBlobInfo_Handler,
		},
		{
			MethodName: "mark_blobs_completed",
			Handler:    _Blobs_MarkBlobsCompleted_Handler,
		},
		{
			MethodName: "delete_blob_by_id",
			Handler:    _Blobs_DeleteBlobById_Handler,
		},
		{
			MethodName: "delete_blobs_by_ids",
			Handler:    _Blobs_DeleteBlobsByIds_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/blobs_v1.proto",
}
